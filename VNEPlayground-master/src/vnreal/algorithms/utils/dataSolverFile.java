/* ***** BEGIN LICENSE BLOCK *****
 * Copyright (C) 2010-2011, The VNREAL Project Team.
 * 
 * This work has been funded by the European FP7
 * Network of Excellence "Euro-NF" (grant agreement no. 216366)
 * through the Specific Joint Developments and Experiments Project
 * "Virtual Network Resource Embedding Algorithms" (VNREAL). 
 *
 * The VNREAL Project Team consists of members from:
 * - University of Wuerzburg, Germany
 * - Universitat Politecnica de Catalunya, Spain
 * - University of Passau, Germany
 * See the file AUTHORS for details and contact information.
 * 
 * This file is part of ALEVIN (ALgorithms for Embedding VIrtual Networks).
 *
 * ALEVIN is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License Version 3 or later
 * (the "GPL"), or the GNU Lesser General Public License Version 3 or later
 * (the "LGPL") as published by the Free Software Foundation.
 *
 * ALEVIN is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * or the GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License and
 * GNU Lesser General Public License along with ALEVIN; see the file
 * COPYING. If not, see <http://www.gnu.org/licenses/>.
 *
 * ***** END LICENSE BLOCK ***** */
package vnreal.algorithms.utils;

/**
 * Class to generate the data file needed by the LP solver 
 * to solve the LP problem. This data file will be processed 
 * with the models HHVNE-Model.mod and VNE-Model-NodeMapping.mod 
 * in /ILP-LP-Models solving a multicommodity flow problem with 
 * the substrate and virtual networks.
 * 
 *  See:
 *  M. Pioro and D. Medhi, Routing, Flow and Capacity Design in
 *  Communication and Computer Networks. San Francisco, CA: Morgan
 *  Kaufmann, 2004.
 * 
 * The data file and model file follow the GNU mathProg language. See:
 * 
 * http://www.gnu.org/software/glpk/#TOCdocumentation
 * 
 * @author Juan Felipe Botero
 * @since 2010-11-20
 */

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.util.*;

import vnreal.constraints.demands.AbstractDemand;
import vnreal.constraints.demands.BandwidthDemand;
import vnreal.constraints.demands.CpuDemand;
import vnreal.constraints.resources.AbstractResource;
import vnreal.constraints.resources.BandwidthResource;
import vnreal.constraints.resources.CpuResource;
import vnreal.network.substrate.SubstrateLink;
import vnreal.network.substrate.SubstrateNetwork;
import vnreal.network.substrate.SubstrateNode;
import vnreal.network.virtual.VirtualLink;
import vnreal.network.virtual.VirtualNetwork;
import vnreal.network.virtual.VirtualNode;

public class dataSolverFile {
	// PRIVATE //
	private FileWriter fstream;

	public dataSolverFile(String aFileName) {
		try {
			this.fstream = new FileWriter(aFileName);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}


	public void TestWrite(){
		try {

			// N\M\F\p\b\alpha\beta\fs\fe\fd
			// 	N\F\b\alpha\fs\fe\fd

			// Create file
			BufferedWriter out = new BufferedWriter(this.fstream);
			out.write("Test");
			out.close();

		}
		catch (Exception e) {// Catch exception if any
			System.err.println("Error: " + e.getMessage());
		}
	}

	/**
	 * Function to create the input file for the LP-solver (GLPK)
	 *
	 */

	/**
	 * Function to create the input file for the LP-solver (GLPK)
	 *
	 * @param substrate
	 *            Substrate Network
	 * @param subsOriginal
	 *            Original substrate network before augmentation
	 * @param vNet
	 *            VNR to be mapped
	 * @param nodeMapping
	 *            Indication of the performed node mapping
	 * @param isNodeMapping
	 *            boolean to know if the data file will be for node or link
	 *            mapping
	 */

	public void createDataSolverFile(SubstrateNetwork substrate,
									 SubstrateNetwork subsOriginal, VirtualNetwork vNet,
									 Map<VirtualNode, SubstrateNode> nodeMapping, boolean isNodeMapping) {
		boolean flag = true;
		SubstrateNode tempSrc, tempDst;
		List<SubstrateNode> listNode = new LinkedList<>();
		SubstrateLink currSLink;
		VirtualLink currVLink;
		Map<String, Double> linksToMap = new LinkedHashMap<String, Double>();
		BandwidthDemand tempBwDem = null;

		try {

			// N\M\F\p\b\alpha\beta\fs\fe\fd
			// 	N\F\b\alpha\fs\fe\fd

			// Create file
			BufferedWriter out = new BufferedWriter(this.fstream);
			out.write("/* Data file autogenerated */");
			out.write("\n\ndata;\n\n");


			out.write("set N :=");
			// Write substrate nodes in data file
			for (SubstrateNode n : subsOriginal.getVertices())
				out.write(" " + Long.toString(n.getId()));



			if(isNodeMapping){
				out.write(";\n\n");
				out.write("set M :=");

				for(SubstrateNode snode : substrate.getVertices()){
					if(!subsOriginal.getVertices().contains(snode)){
						listNode.add(snode);
					}
				}


				// Write Meta nodes in data file
				for(SubstrateNode n : listNode){
					out.write(" " + Long.toString(n.getId()));
				}
			}


			out.write(";\n\n");
			out.write("set F :=");
			// Write virtual links in data file
			for (Iterator<VirtualLink> links = vNet.getEdges().iterator(); links
					.hasNext();) {
				currVLink = links.next();
				tempSrc = nodeMapping.get(vNet.getEndpoints(currVLink).getFirst());
				tempDst = nodeMapping.get(vNet.getEndpoints(currVLink).getSecond());
				if (!tempSrc.equals(tempDst)) {
					for (AbstractDemand dem : currVLink) {
						if (dem instanceof BandwidthDemand) {
							tempBwDem = (BandwidthDemand) dem;
							break;
						}
					}

					if (!linksToMap
							.containsKey(Long.toString(tempSrc.getId())
									+ " " + Long.toString(tempDst.getId()))) {
						out.write(" " + Long.toString(currVLink.getId()));
						linksToMap.put(Long.toString(currVLink.getId()) + " " + Long.toString(tempSrc.getId()) + " "
										+ Long.toString(tempDst.getId()),
								tempBwDem.getDemandedBandwidth());

					} else {
						double tempBw = linksToMap.get(Long.toString(tempSrc
								.getId())
								+ " "
								+ Long.toString(tempDst.getId()))
								+ tempBwDem.getDemandedBandwidth();
						linksToMap.put(Long.toString(currVLink.getId()) + " " + Long.toString(tempSrc.getId()) + " "
								+ Long.toString(tempDst.getId()), tempBw);

					}
				} else {
					// FIXME future work if node overload is considered and a
					// virtual link is mapped from one
					// substrate node to the same substrate node
				}
			}



			// Problem!!!!
			if (isNodeMapping) {
				out.write(";\n\n");
				out.write("param: \t\tp :=\n");
				for (Iterator<SubstrateNode> nodes = substrate.getVertices()
						.iterator(); nodes.hasNext();) {
					SubstrateNode temp = nodes.next();
					for (AbstractResource res : temp) {
						// Change it, and instance of abstract resource
						if (res instanceof CpuResource) {
							if (flag) {
								flag = false;
							} else {
								out.write("\n");
							}
							out.write(Long.toString(temp.getId())
									+ " \t\t"
									+ Double.toString(((CpuResource) res)
									.getAvailableCycles()));
							break;
						}
					}
				}
			}





			// Write substrate links bandwidth capacity problem!!!!!
			out.write(";\n\n");
			out.write("param b:\n");
			for(Iterator<SubstrateNode> nodes = substrate.getVertices()
					.iterator();nodes.hasNext();){
				SubstrateNode tmpn = nodes.next();

				out.write(Long.toString(tmpn.getId()) + " ");
			}
			out.write(":=\n");

			Map<String,Map<String,Double>> bTwoDim = new LinkedHashMap<>();
			for(Iterator<SubstrateNode> nodesi = substrate.getVertices()
					.iterator();nodesi.hasNext();){
				SubstrateNode tmpi = nodesi.next();
				Map<String,Double> tmpOneDim = new LinkedHashMap<>();
				for(Iterator<SubstrateNode> nodesj = substrate.getVertices()
						.iterator();nodesj.hasNext();){
					SubstrateNode tmpj = nodesj.next();
					double tmpbw = 0.0;
					if(containEdge(tmpi,tmpj,substrate)){
						for (AbstractResource res : getEdge(tmpi,tmpj,substrate)) {
							// Change it, and instance of abstract resource
							if (res instanceof BandwidthResource) {
								tmpbw = ((BandwidthResource) res)
										.getAvailableBandwidth();
							}
						}
					}else{
						tmpbw = 0.0;
					}

					tmpOneDim.put(Long.toString(tmpj.getId()),Double.valueOf(tmpbw));
					bTwoDim.put(Long.toString(tmpi.getId()),tmpOneDim);

				}


			}

			for(Iterator<SubstrateNode> nodesi = substrate.getVertices()
					.iterator();nodesi.hasNext();){
				SubstrateNode tmpi = nodesi.next();
				out.write(Long.toString(tmpi.getId()) + " ");
				for(Iterator<SubstrateNode> nodesj = substrate.getVertices()
						.iterator();nodesj.hasNext();){
					SubstrateNode tmpj = nodesj.next();
					double tmpb = bTwoDim.get(Long.toString(tmpi.getId())).get(Long.toString(tmpj.getId()));
					out.write(Double.toString(tmpb) + " ");
				}
				out.write("\n");
			}

			out.write(";\n\n");
			out.write("param: \t\tfs :=\n");
			for (Iterator<String> linkIterator = linksToMap.keySet().iterator(); linkIterator
					.hasNext();) {
				String currLink = linkIterator.next();
				String[] endpoints = currLink.split(" ");
				if (flag) {
					flag = false;
				} else {
					out.write("\n");
				}
				out.write(endpoints[0]
						+ " \t\t" + endpoints[1]);

			}

			out.write(";\n\n");
			out.write("param: \t\tfe :=\n");
			for (Iterator<String> linkIterator = linksToMap.keySet().iterator(); linkIterator
					.hasNext();) {
				String currLink = linkIterator.next();
				String[] endpoints = currLink.split(" ");
				if (flag) {
					flag = false;
				} else {
					out.write("\n");
				}
				out.write(endpoints[0]
						+ " \t\t" + endpoints[2]);
			}

			// Write flow demands
			out.write(";\n\n");
			out.write("param: \t\tfd :=\n");
			for (Iterator<String> linkIterator = linksToMap.keySet().iterator(); linkIterator
					.hasNext();) {
				String currLink = linkIterator.next();
				String[] endpoints = currLink.split(" ");
				if (flag) {
					flag = false;
				} else {
					out.write("\n");
				}
				out.write(endpoints[0]
						+ " \t\t"
						+ Double.toString(MiscelFunctions
						.round(linksToMap.get(currLink), 3)));
			}

			out.write(";");
			out.write("\n\nend;\n");
			// Close the output stream
			out.close();


		} catch (Exception e) {// Catch exception if any
			System.err.println("Error: " + e.getMessage());
		}

	}


	private boolean containEdge(SubstrateNode n1, SubstrateNode n2, SubstrateNetwork sn){
		boolean result = false;
		for(Iterator<SubstrateLink> links = sn.getEdges()
				.iterator();links.hasNext();){
			SubstrateLink l = links.next();

			if((sn.getEndpoints(l).getFirst() == n1
					&& sn.getEndpoints(l).getSecond() == n2)
					||(sn.getEndpoints(l).getFirst() == n2
					&& sn.getEndpoints(l).getSecond() == n1) ){
				result = true;
				break;
			}
		}

		return result;

	}

	private SubstrateLink getEdge(SubstrateNode n1, SubstrateNode n2, SubstrateNetwork sn){

		for(Iterator<SubstrateLink> links = sn.getEdges()
				.iterator();links.hasNext();){
			SubstrateLink l = links.next();

			if((sn.getEndpoints(l).getFirst() == n1
					&& sn.getEndpoints(l).getSecond() == n2)
					||(sn.getEndpoints(l).getFirst() == n2
					&& sn.getEndpoints(l).getSecond() == n1) ){
				return l;

			}
		}

		return null;
	}

}
